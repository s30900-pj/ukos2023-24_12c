# Copyright 2015 Tomasz Idzikowski
# Przedmiot: UKOS
# Skrypt: Wprowadzenie do podstaw PowerShell-a
#
# Żeby uruchomić jakikolwiek skrypt w PowerShell-u to domyślnie musi on być podpisany przez Microsoft
# Ale można to przełączyć i w rzeczywistości praktycznie każdy tak robi bo inaczej nie da się używać PowerShell-a
# Także, jak będziesz miał problem z uruchomieniem tego skryptu to uruchom powłokę PowerShell-a z uprawnieniami Admina
# W pisz poniższe polecenie a następnie je zatwierdź (będzie dodatkowe pytanie o przełączenie)
#
# Poniższa linijka została już na stacjach w laboratorium wykonana. Nie należy jej uruchamiać w laboratorium.
# Bo wymaga to uprawnień administratora.
#
# PS C:\Users\user> Set-ExecutionPolicy Bypass
# Odpowiedz "T" lub "Y" (nie wiem jak to będzie wyglądać na polskim windowsie)
Uruchamiam powershell jako administrator i wpisuję komendę "Set-ExecutionPolicy Bypass"
#
# Wtedy jak to będzie już przełączone to jako zwykły użytkownik będziesz mógł sobie uruchamiać swoje skrypty
#
# Zanim zaczniesz czytać i wykonywać dalej instrukcje, które zawarłem poniżej zwróć uwagę na to jak to jest napisane
# Wszystko to co możesz bez problemu uruchomić ma przed sobą sam znak "#" a po nim NIE MA spacji. Jeśli jest spacja
# to jest to komentarz tak jak ten tu. W linii 25 masz coś co można uruchomić.
#
#
#
# Gdybyś potrzebował pomocy z dowolnym poleceniem by zobaczyć jaką ma składnię to pomoc używa się tak:
#Get-Help Get-ExecutionPolicy
Wpisuję komendę, akceptuję run Update-Help wciskając Y, dokonuje się update, wynik:
"
NAME
    Get-ExecutionPolicy

SYNOPSIS
    Gets the execution policies for the current session.


SYNTAX
    Get-ExecutionPolicy [[-Scope] {CurrentUser | LocalMachine | MachinePolicy | Process | UserPolicy}] [-List] [<Common
    Parameters>]


DESCRIPTION
    To display the execution policies for each scope in the order of precedence, use `Get-ExecutionPolicy -List`. To se
    e the effective execution policy for your PowerShell session use `Get-ExecutionPolicy` with no parameters.

    The effective execution policy is determined by execution policies that are set by `Set-ExecutionPolicy` and Group
    Policy settings.

    For more information, see about_Execution_Policies (../Microsoft.PowerShell.Core/about/about_Execution_Policies.md)
    .


RELATED LINKS
    Online Version: https://learn.microsoft.com/powershell/module/microsoft.powershell.security/get-executionpolicy?vie
    w=powershell-5.1&WT.mc_id=ps-gethelp
    about_Execution_Policies
    about_Group_Policy_Settings
    Get-AuthenticodeSignature
    Set-AuthenticodeSignature
    Set-ExecutionPolicy

REMARKS
    To see the examples, type: "get-help Get-ExecutionPolicy -examples".
    For more information, type: "get-help Get-ExecutionPolicy -detailed".
    For technical information, type: "get-help Get-ExecutionPolicy -full".
    For online help, type: "get-help Get-ExecutionPolicy -online"
"

#
# A żeby zobaczyć przykłady użycia:
#Get-Help Get-ExecutionPolicy -Examples
Wpisuję komendę, otrzymując wynik:
"
NAME
    Get-ExecutionPolicy

SYNOPSIS
    Gets the execution policies for the current session.


    ------------ Example 1: Get all execution policies ------------

    Get-ExecutionPolicy -List

    Scope          ExecutionPolicy
    -----          ---------------
    MachinePolicy  Undefined
    UserPolicy     Undefined
    Process        Undefined
    CurrentUser    AllSigned
    LocalMachine   Undefined

    The `Get-ExecutionPolicy` cmdlet uses the List parameter to display each scope's execution policy.
    -------------- Example 2: Set an execution policy --------------

    Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine
    Get-ExecutionPolicy -List

    Scope ExecutionPolicy
            ----- ---------------
    MachinePolicy       Undefined
       UserPolicy       Undefined
          Process       Undefined
      CurrentUser       AllSigned
     LocalMachine    RemoteSigned

    The `Set-ExecutionPolicy` cmdlet uses the ExecutionPolicy parameter to specify the `RemoteSigned` policy. The Scope
     parameter specifies the default scope value, `LocalMachine`. To view the execution policy settings, use the `Get-E
    xecutionPolicy` cmdlet with the List parameter.
    -------- Example 3: Get the effective execution policy --------

    PS> Get-ExecutionPolicy -List

            Scope ExecutionPolicy
            ----- ---------------
    MachinePolicy       Undefined
       UserPolicy       Undefined
          Process       Undefined
      CurrentUser       AllSigned
     LocalMachine    RemoteSigned

    PS> Get-ExecutionPolicy

    AllSigned

    The `Get-ExecutionPolicy` cmdlet uses the List parameter to display each scope's execution policy. The `Get-Executi
    onPolicy` cmdlet is run without a parameter to display the effective execution policy, `AllSigned`.
    Example 4: Unblock a script to run it without changing the execution policy

    PS> Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine

    PS> Get-ExecutionPolicy

    RemoteSigned

    PS> .\Start-ActivityTracker.ps1

    .\Start-ActivityTracker.ps1 : File .\Start-ActivityTracker.ps1 cannot be loaded.
    The file .\Start-ActivityTracker.ps1 is not digitally signed.
    The script will not execute on the system.
    For more information, see about_Execution_Policies at https://go.microsoft.com/fwlink/?LinkID=135170.
    At line:1 char:1
    + .\Start-ActivityTracker.ps1
    + ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : NotSpecified: (:) [], PSSecurityException
    + FullyQualifiedErrorId : UnauthorizedAccess

    PS> Unblock-File -Path .\Start-ActivityTracker.ps1

    PS> Get-ExecutionPolicy

    RemoteSigned

    PS> .\Start-ActivityTracker.ps1

    Task 1:

    The `Set-ExecutionPolicy` uses the ExecutionPolicy parameter to specify the `RemoteSigned` policy. The policy is se
    t for the default scope, `LocalMachine`.

    The `Get-ExecutionPolicy` cmdlet shows that `RemoteSigned` is the effective execution policy for the current PowerS
    hell session.

    The `Start-ActivityTracker.ps1` script is executed from the current directory. The script is blocked by `RemoteSign
    ed` because the script isn't digitally signed.

    For this example, the script's code was reviewed and verified as safe to run. The `Unblock-File` cmdlet uses the Pa
    th parameter to unblock the script.

    To verify that `Unblock-File` didn't change the execution policy, `Get-ExecutionPolicy` displays the effective exec
    ution policy, `RemoteSigned`.

    The script, `Start-ActivityTracker.ps1` is executed from the current directory. The script begins to run because it
     was unblocked by the `Unblock-File` cmdlet.
"
Dostajemy przykłady użycia polecenia z krótkim objasnieniem
#
# Komendy w PS (powershellu) mają pewną stałą konwencję nazewniczą. Jest to: Czasownik-NaCzymMaOperować
# Np. Get-ExecutionPolicy, Set-ExecutionPolicy, Find-Module, Add-User, Create-Item itd...
# Nazwa zawsze jest zbudowana w ten sam sposób.
# Także aby zobaczyć jaki masz "ExecutionPolicy" robisz "Get-ExecutionPolicy" i dostaniesz informację
#
# PS ma wiele modułów, które są domyślnie zainstalowane ale nie uruchomione i trzeba je na żądanie ładować.
# Ale najpierw trzeba wiedzieć co można załadować
#
# Poniższa linia zwróci Tobie wszystkie dostepne w danej chwili moduły. Może się chwilę wykonywać bo najpierw musi zebrać listę.
#Get-Module -ListAvailable
Wpisuję komendę, wynik:
    Directory: C:\Program Files\WindowsPowerShell\Modules


ModuleType Version    Name                                ExportedCommands
---------- -------    ----                                ----------------
Script     1.0.1      Microsoft.PowerShell.Operation.V... {Get-OperationValidation, Invoke-OperationValidation}
Binary     1.0.0.1    PackageManagement                   {Find-Package, Get-Package, Get-PackageProvider, Get-Packa...
Script     3.4.0      Pester                              {Describe, Context, It, Should...}
Script     1.0.0.1    PowerShellGet                       {Install-Module, Find-Module, Save-Module, Update-Module...}
Script     2.0.0      PSReadLine                          {Get-PSReadLineKeyHandler, Set-PSReadLineKeyHandler, Remov...


    Directory: C:\Windows\system32\WindowsPowerShell\v1.0\Modules


ModuleType Version    Name                                ExportedCommands
---------- -------    ----                                ----------------
Manifest   1.0.0.0    AppBackgroundTask                   {Disable-AppBackgroundTaskDiagnosticLog, Enable-AppBackgro...
Manifest   2.0.1.0    Appx                                {Add-AppxPackage, Get-AppxPackage, Get-AppxPackageAutoUpda...
Manifest   1.0.0.0    BitLocker                           {Unlock-BitLocker, Suspend-BitLocker, Resume-BitLocker, Re...
Script     2.0.0.0    BitsTransfer                        {Add-BitsFile, Complete-BitsTransfer, Get-BitsTransfer, Re...
Manifest   1.0.0.0    CimCmdlets                          {Get-CimAssociatedInstance, Get-CimClass, Get-CimInstance,...
Manifest   1.0        ConfigDefender                      {Get-MpPreference, Set-MpPreference, Add-MpPreference, Rem...
Manifest   1.0        ConfigDefenderPerformance           {New-MpPerformanceRecording, Get-MpPerformanceReport}
Manifest   1.0        Defender                            {Get-MpPreference, Set-MpPreference, Add-MpPreference, Rem...
Manifest   1.0        DefenderPerformance                 {New-MpPerformanceRecording, Get-MpPerformanceReport}
Manifest   1.0.3.0    DeliveryOptimization                {Get-DeliveryOptimizationLog, Get-DeliveryOptimizationLogA...
Manifest   1.0.0.0    DirectAccessClientComponents        {Disable-DAManualEntryPointSelection, Enable-DAManualEntry...
Script     3.0        Dism                                {Add-AppProvisionedSharedPackageContainer, Add-AppxProvisi...
Manifest   1.0.0.0    DnsClient                           {Resolve-DnsName, Clear-DnsClientCache, Get-DnsClient, Get...
Manifest   1.0.0.0    EventTracingManagement              {Start-EtwTraceSession, New-EtwTraceSession, Get-EtwTraceS...
Script     2022.3.... Get-NetView                         Get-NetView
Manifest   2.1.0.0    International                       {Copy-UserInternationalSettingsToSystem, Get-WinDefaultInp...
Manifest   1.0.0.0    iSCSI                               {Get-IscsiTargetPortal, New-IscsiTargetPortal, Remove-Iscs...
Script     1.0.0.0    ISE                                 {New-IseSnippet, Import-IseSnippet, Get-IseSnippet}
Manifest   1.0.0.0    Kds                                 {Add-KdsRootKey, Get-KdsRootKey, Test-KdsRootKey, Set-KdsC...
Manifest   1.0        LanguagePackManagement              {Install-Language, Uninstall-Language, Get-InstalledLangua...
Script     1.0.0.0    LAPS                                {Find-LapsADExtendedRights, Get-LapsADPassword, Invoke-Lap...
Manifest   1.0.1.0    Microsoft.PowerShell.Archive        {Compress-Archive, Expand-Archive}
Manifest   3.0.0.0    Microsoft.PowerShell.Diagnostics    {Get-WinEvent, Get-Counter, Import-Counter, Export-Counter...
Manifest   3.0.0.0    Microsoft.PowerShell.Host           {Start-Transcript, Stop-Transcript}
Manifest   1.0.0.0    Microsoft.PowerShell.LocalAccounts  {Add-LocalGroupMember, Disable-LocalUser, Enable-LocalUser...
Manifest   3.1.0.0    Microsoft.PowerShell.Management     {Add-Content, Clear-Content, Clear-ItemProperty, Join-Path...
Script     1.0        Microsoft.PowerShell.ODataUtils     Export-ODataEndpointProxy
Manifest   3.0.0.0    Microsoft.PowerShell.Security       {Get-Acl, Set-Acl, Get-PfxCertificate, Get-Credential...}
Manifest   3.1.0.0    Microsoft.PowerShell.Utility        {Format-List, Format-Custom, Format-Table, Format-Wide...}
Manifest   1.0.0      Microsoft.Windows.Bcd.Cmdlets       {Copy-BcdEntry, Disable-BcdElementBootDebug, Disable-BcdEl...
Manifest   3.0.0.0    Microsoft.WSMan.Management          {Disable-WSManCredSSP, Enable-WSManCredSSP, Get-WSManCredS...
Manifest   1.0        MMAgent                             {Disable-MMAgent, Enable-MMAgent, Set-MMAgent, Get-MMAgent...
Manifest   1.0.0.0    MsDtc                               {New-DtcDiagnosticTransaction, Complete-DtcDiagnosticTrans...
Manifest   2.0.0.0    NetAdapter                          {Disable-NetAdapter, Disable-NetAdapterBinding, Disable-Ne...
Manifest   2.0.0.0    NetConnection                       {Get-NetConnectionProfile, Set-NetConnectionProfile}
Manifest   1.0.0.0    NetEventPacketCapture               {New-NetEventSession, Remove-NetEventSession, Get-NetEvent...
Manifest   2.0.0.0    NetLbfo                             {Add-NetLbfoTeamMember, Add-NetLbfoTeamNic, Get-NetLbfoTea...
Manifest   1.0.0.0    NetNat                              {Get-NetNat, Get-NetNatExternalAddress, Get-NetNatStaticMa...
Manifest   2.0.0.0    NetQos                              {Get-NetQosPolicy, Set-NetQosPolicy, Remove-NetQosPolicy, ...
Manifest   2.0.0.0    NetSecurity                         {Get-DAPolicyChange, New-NetIPsecAuthProposal, New-NetIPse...
Manifest   1.0.0.0    NetSwitchTeam                       {New-NetSwitchTeam, Remove-NetSwitchTeam, Get-NetSwitchTea...
Manifest   1.0.0.0    NetTCPIP                            {Get-NetIPAddress, Get-NetIPInterface, Get-NetIPv4Protocol...
Manifest   1.0.0.0    NetworkConnectivityStatus           {Get-DAConnectionStatus, Get-NCSIPolicyConfiguration, Rese...
Manifest   1.0.0.0    NetworkSwitchManager                {Disable-NetworkSwitchEthernetPort, Enable-NetworkSwitchEt...
Manifest   1.0.0.0    NetworkTransition                   {Add-NetIPHttpsCertBinding, Disable-NetDnsTransitionConfig...
Manifest   1.0.0.0    PcsvDevice                          {Get-PcsvDevice, Start-PcsvDevice, Stop-PcsvDevice, Restar...
Binary     1.0.0.0    PersistentMemory                    {Get-PmemDisk, Get-PmemPhysicalDevice, Get-PmemUnusedRegio...
Manifest   1.0.0.0    PKI                                 {Add-CertificateEnrollmentPolicyServer, Export-Certificate...
Manifest   1.0.0.0    PnpDevice                           {Get-PnpDevice, Get-PnpDeviceProperty, Enable-PnpDevice, D...
Manifest   1.1        PrintManagement                     {Add-Printer, Add-PrinterDriver, Add-PrinterPort, Get-Prin...
Binary     1.0.12     ProcessMitigations                  {Get-ProcessMitigation, Set-ProcessMitigation, ConvertTo-P...
Script     3.0        Provisioning                        {Install-ProvisioningPackage, Export-ProvisioningPackage, ...
Manifest   1.1        PSDesiredStateConfiguration         {Set-DscLocalConfigurationManager, Start-DscConfiguration,...
Script     1.0.0.0    PSDiagnostics                       {Disable-PSTrace, Disable-PSWSManCombinedTrace, Disable-WS...
Binary     1.1.0.0    PSScheduledJob                      {New-JobTrigger, Add-JobTrigger, Remove-JobTrigger, Get-Jo...
Manifest   2.0.0.0    PSWorkflow                          {New-PSWorkflowExecutionOption, New-PSWorkflowSession, nwsn}
Manifest   1.0.0.0    PSWorkflowUtility                   Invoke-AsWorkflow
Manifest   1.0.0.0    ScheduledTasks                      {Get-ScheduledTask, Set-ScheduledTask, Register-ScheduledT...
Manifest   2.0.0.0    SecureBoot                          {Confirm-SecureBootUEFI, Set-SecureBootUEFI, Get-SecureBoo...
Manifest   2.0.0.0    SmbShare                            {Get-SmbShare, Remove-SmbShare, Set-SmbShare, Block-SmbSha...
Manifest   2.0.0.0    SmbWitness                          {Get-SmbWitnessClient, Move-SmbWitnessClient, gsmbw, msmbw...
Manifest   1.0.0.1    StartLayout                         {Export-StartLayout, Import-StartLayout, Export-StartLayou...
Manifest   2.0.0.0    Storage                             {Add-InitiatorIdToMaskingSet, Add-PartitionAccessPath, Add...
Manifest   1.0.0.0    StorageBusCache                     {Clear-StorageBusDisk, Disable-StorageBusCache, Disable-St...
Manifest   2.0.0.0    TLS                                 {New-TlsSessionTicketKey, Enable-TlsSessionTicketKey, Disa...
Manifest   1.0.0.0    TroubleshootingPack                 {Get-TroubleshootingPack, Invoke-TroubleshootingPack}
Manifest   2.0.0.0    TrustedPlatformModule               {Get-Tpm, Initialize-Tpm, Clear-Tpm, Unblock-Tpm...}
Script     1.0.0.0    VMDirectStorage                     {Get-VMDirectVirtualDisk, Add-VMDirectVirtualDisk, Remove-...
Manifest   2.0.0.0    VpnClient                           {Add-VpnConnection, Set-VpnConnection, Remove-VpnConnectio...
Manifest   1.0.0.0    Wdac                                {Get-OdbcDriver, Set-OdbcDriver, Get-OdbcDsn, Add-OdbcDsn...}
Manifest   2.0.0.0    Whea                                {Get-WheaMemoryPolicy, Set-WheaMemoryPolicy}
Manifest   1.0.0.0    WindowsDeveloperLicense             {Get-WindowsDeveloperLicense, Unregister-WindowsDeveloperL...
Script     1.0        WindowsErrorReporting               {Enable-WindowsErrorReporting, Disable-WindowsErrorReporti...
Manifest   1.0.0.0    WindowsSearch                       {Get-WindowsSearchSetting, Set-WindowsSearchSetting}
Manifest   1.0.0.0    WindowsUpdate                       Get-WindowsUpdateLog
Script     1.0.0.0    WinHttpProxy                        {Get-WinhttpProxy, Export-WinhttpProxy, Reset-WinhttpProxy...
"
Dostarcza nam listę dostępnych modułów
#
#
#
# INFO: Poniższa sekcja została przygotowana na Windows 10. Na Win 7 niektóre dane są niedostępne.
#
# To co zwróci powyższe polecenie to lista/kolekcja, którą można przetworzyć.
# Powiedzmy, że chcemy wyszukać tylko te moduły, których wersja jest większa lub równa 2.0 a wszystkie inne nie.
# Wtedy korzysta się z "Where-Object" lub jego skrótu "?"
#
# Znak "|" to potok (pipeline), który uruchamia kolejne polecenie na danych wyjściowych z poprzedniego polecenia
# Jeśli podaje się kolekcję/listę/tablicę to poszczególne elementy tej kolecji po znaku | są widoczne jako "$_"
# To taka specjalna zmienna, która jest automatycznie tworzona przez powershell'a kiedy się operuje na kolekcjach.
#
# Poniższa linia zwróci tylko te moduły, których wersja jest >= 2.0.0.0
#Get-Module -ListAvailable | ? {$_.Version -ge "2.0.0.0"}
Wpisuję komendę, wynik:
"
Directory: C:\Program Files\WindowsPowerShell\Modules


ModuleType Version    Name                                ExportedCommands
---------- -------    ----                                ----------------
Script     3.4.0      Pester                              {Describe, Context, It, Should...}


    Directory: C:\Windows\system32\WindowsPowerShell\v1.0\Modules


ModuleType Version    Name                                ExportedCommands
---------- -------    ----                                ----------------
Manifest   2.0.1.0    Appx                                {Add-AppxPackage, Get-AppxPackage, Get-AppxPackageAutoU...
Script     2.0.0.0    BitsTransfer                        {Add-BitsFile, Complete-BitsTransfer, Get-BitsTransfer,...
Script     3.0        Dism                                {Add-AppProvisionedSharedPackageContainer, Add-AppxProv...
Script     2022.3.... Get-NetView                         Get-NetView
Manifest   2.1.0.0    International                       {Copy-UserInternationalSettingsToSystem, Get-WinDefault...
Manifest   3.0.0.0    Microsoft.PowerShell.Diagnostics    {Get-WinEvent, Get-Counter, Import-Counter, Export-Coun...
Manifest   3.0.0.0    Microsoft.PowerShell.Host           {Start-Transcript, Stop-Transcript}
Manifest   3.1.0.0    Microsoft.PowerShell.Management     {Add-Content, Clear-Content, Clear-ItemProperty, Join-P...
Manifest   3.0.0.0    Microsoft.PowerShell.Security       {Get-Acl, Set-Acl, Get-PfxCertificate, Get-Credential...}
Manifest   3.1.0.0    Microsoft.PowerShell.Utility        {Format-List, Format-Custom, Format-Table, Format-Wide...}
Manifest   3.0.0.0    Microsoft.WSMan.Management          {Disable-WSManCredSSP, Enable-WSManCredSSP, Get-WSManCr...
Manifest   2.0.0.0    NetAdapter                          {Disable-NetAdapter, Disable-NetAdapterBinding, Disable...
Manifest   2.0.0.0    NetConnection                       {Get-NetConnectionProfile, Set-NetConnectionProfile}
Manifest   2.0.0.0    NetLbfo                             {Add-NetLbfoTeamMember, Add-NetLbfoTeamNic, Get-NetLbfo...
Manifest   2.0.0.0    NetQos                              {Get-NetQosPolicy, Set-NetQosPolicy, Remove-NetQosPolic...
Manifest   2.0.0.0    NetSecurity                         {Get-DAPolicyChange, New-NetIPsecAuthProposal, New-NetI...
Script     3.0        Provisioning                        {Install-ProvisioningPackage, Export-ProvisioningPackag...
Manifest   2.0.0.0    PSWorkflow                          {New-PSWorkflowExecutionOption, New-PSWorkflowSession, ...
Manifest   2.0.0.0    SecureBoot                          {Confirm-SecureBootUEFI, Set-SecureBootUEFI, Get-Secure...
Manifest   2.0.0.0    SmbShare                            {Get-SmbShare, Remove-SmbShare, Set-SmbShare, Block-Smb...
Manifest   2.0.0.0    SmbWitness                          {Get-SmbWitnessClient, Move-SmbWitnessClient, gsmbw, ms...
Manifest   2.0.0.0    Storage                             {Add-InitiatorIdToMaskingSet, Add-PartitionAccessPath, ...
Manifest   2.0.0.0    TLS                                 {New-TlsSessionTicketKey, Enable-TlsSessionTicketKey, D...
Manifest   2.0.0.0    TrustedPlatformModule               {Get-Tpm, Initialize-Tpm, Clear-Tpm, Unblock-Tpm...}
Manifest   2.0.0.0    VpnClient                           {Add-VpnConnection, Set-VpnConnection, Remove-VpnConnec...
Manifest   2.0.0.0    Whea                                {Get-WheaMemoryPolicy, Set-WheaMemoryPolicy}
"
Komenda zwróciła nam moduły od wersji 2.0.0.0 w górę
#
# Moduły mogą mieć wiele poleceń (to co jest w kolumnie ExportedCommands wyświetlone po przecinku)
# A my byśmy chcieli mieć listę wszystkich poleceń w tych modułach po przefiltrowaniu wersji powyżej.
#
# Tak jak "?" jest skrótem na Where-Object, tak "%" jest skrótem na While-Object czyli pętlę
# Poniższa linia wyświetli wszystkie polecenia (cmdlet - "Komandlety") w dostępnych modułach, których wersja >= 2.0.0.0
#Get-Module -ListAvailable | ? {$_.Version -ge "2.0.0.0"} | % {Get-Command -Module $_.Name}
Wpisuję komendę, komenda zwróciła nam ogromny bazę poleceń od wersji 2.0.0.0(na tyle duży kod, że pozwolę sobie go nie wklejać)

#
# Teraz byśmy chcieli jeszcze wyświetlić wszystkie te, które mają w nazwie "Add-" lub "Get-"
#Get-Module -ListAvailable | ? {$_.Version -ge "2.0.0.0"} | % {Get-Command -Module $_.Name} | ? {($_.Name -like "Add-*") -or ($_.Name -like "Get-*")}
Komenda zwróciła nam wszystkie polecenia od wersji 2.0.0.0 z "Add-" lub "Get-" w nazwie
#
# A teraz byśmy chcieli je wypisać w postaci tabelki graficznej otworzonej w nowym okienku
#Get-Module -ListAvailable | ? {$_.Version -ge "2.0.0.0"} | % {Get-Command -Module $_.Name} | ? {($_.Name -like "Add-*") -or ($_.Name -like "Get-*")} | Out-GridView
Wpisuję komendę, zwróciło mi polecenia z poprzedniego zadania, aczkolwiek w nowym okienku 
#
# albo do pliku
#$nazwaPliku = "mojaNazwaPliku.txt"
#Get-Module -ListAvailable | ? {$_.Version -ge "2.0.0.0"} | % {Get-Command -Module $_.Name} | ? {($_.Name -like "Add-*") -or ($_.Name -like "Get-*")} | Out-File $env:TEMP\$nazwaPliku
Zwróciło mi błąd
"
Out-File : Nie można odnaleźć części ścieżki „C:\Users\Grzeg\AppData\Local\Temp\”.
At line:1 char:152
+ ... Add-*") -or ($_.Name -like "Get-*")} | Out-File $env:TEMP\$nazwaPliku
+                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (:) [Out-File], DirectoryNotFoundException
    + FullyQualifiedErrorId : FileOpenFailure,Microsoft.PowerShell.Commands.OutFileCommand
"
#
# albo nic z tym nie robić tylko by się przetworzyło ale nie wypisywało
#Get-Module -ListAvailable | ? {$_.Version -ge "2.0.0.0"} | % {Get-Command -Module $_.Name} | ? {($_.Name -like "Add-*") -or ($_.Name -like "Get-*")} | Out-Null
Wpisałem polecenie, wykonało się, aczkolwiek nic nie zwróciło na ekran
#
#
#
#
#
#
#
# Dobrze, to listy już mamy opanowane. To teraz w końcu byśmy chcieli załadować jakiś moduł np. BitsTransfer (do zarządzania przesyłaniem danych w tle)
#Import-Module BitsTransfer
#
# można też użyć aliasu na Import-Module w formie:
#ipmo BitsTransfer
moduł został zainicjalizowany
#
# Wylistujmy wszystkie komendy w tym module
#Get-Command -Module BitsTransfer
Polecenie zostało wpisane, wyświetliło komendy modułu, wynik
"
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Cmdlet          Add-BitsFile                                       2.0.0.0    BitsTransfer
Cmdlet          Complete-BitsTransfer                              2.0.0.0    BitsTransfer
Cmdlet          Get-BitsTransfer                                   2.0.0.0    BitsTransfer
Cmdlet          Remove-BitsTransfer                                2.0.0.0    BitsTransfer
Cmdlet          Resume-BitsTransfer                                2.0.0.0    BitsTransfer
Cmdlet          Set-BitsTransfer                                   2.0.0.0    BitsTransfer
Cmdlet          Start-BitsTransfer                                 2.0.0.0    BitsTransfer
Cmdlet          Suspend-BitsTransfer                               2.0.0.0    BitsTransfer
"
#
# Ok. To teraz postarajmy się użyć tego cuda do pobrania jakiegoś dużego pliku by było widać proces ściągania.
# Ściągnijmy obraz maszyny wirtualnej do javy.
# UWAGA: Sprawdz na poczatku przez normalna przegladarke czy ponizsze adresy dzialaja.
# UWAGA: Jesli przez przegladarke ten adres nie dziala to prosze znalesc jakis inny duzy plik w Internecie.
# UWAGA: Alternatywnie prowadzacy moze udostepnic jakis serwer www uruchomiony na czas zajec.
# INFO: Obrazy używane na zajęciach są dostępne po zalogowaniu pod adresem:
# INFO: http://szuflandia.pjwstk.edu.pl/pub/
# INFO: Logowanie przez login i hasło do konta studenckiego
#
Szuflandia zwraca błąd 404
#
# UKOS: 18 grudnia 2022
# INFO: Uzyjemy serwera ktory uruchomie na zajeciach
# INFO: Login = student    haslo = ukos    (te dane podac ponizej do okna dialogowego Get-Credential zamiast swojego loginu i hasla studenckiego)
# INFO: Adres: http://IP_KOMPUTERA_PROWADZACEGO:8080/index.html (lub inny plik ktory wskaze)
# INFO: Prosze ustawic parametr: -Authentication Basic
#
# Zapisz sobie swoje dane logowania (w bezpieczny sposób) do zmiennej by nie wpisywać ich za każdym razem
# INFO: Do następnego zadania proszę wpisać username w formacie: sXXXXX@pjwstk.edu.pl
#$cred = Get-Credential
#
# INFO: Ustaw parametr Destination na lokalizacje gdzie mozna zapisywac tymczasowo duze pliki.
# INFO: Czyli na dysk 3-4 Users lub analogiczny.
# Teraz rozpocznij przesyłać plik
# Takie przesyłanie pliku może trwać długo.
#Start-BitsTransfer -Source http://szuflandia.pjwstk.edu.pl/pub/repo/java/lubuntu_13_04_v02.zip -Destination D:\ -Credential $cred -Authentication Negotiate
#
# Jeśli chcesz to uczynić w sposób asynchroniczny (czyli taki, który nie blokuje konsoli) to można to zrobić tak
#$job = Start-BitsTransfer -Source http://szuflandia.pjwstk.edu.pl/pub/repo/java/lubuntu_13_04_v02.zip -Destination D:\ -Credential $cred -Authentication Negotiate -Asynchronous -DisplayName "Moj Bits Transfer"
Użyłem tej komendy, by nie blokować konsoli, pobieranie nie wpłynęło na pracę w terminalu
#
# By zobaczyć jaki jest stan transferu można użyć takiej komendy.
#Get-BitsTransfer
Wynik:
"
JobId                                DisplayName       TransferType JobState OwnerAccount
-----                                -----------       ------------ -------- ------------
39231aa2-f2f2-4287-85e7-ddd1a2adf595 Moj Bits Transfer Download     Error    GRZEGORZ\Grzeg
"
Jak widać w statusie pokazuje error
#
# Zwrócić uwagę należy na stan w kolumnie JobState. Jeśli będzie tam Transferred to aby ukończyć całość i dostać pobierany plik
# trzeba jeszcze zakończyć job transferu. Robi się to tak
#Complete-BitsTransfer -BitsJob $job
#
# Teraz plik jest już dostępny w katalogu docelowym
#
#
#
# Skoro wiemy, że niektóre komendy wykonują się długo, to może byśmy chcieli zmierzyć czas wykonania polecenia.
# Czasem może się to okazać potrzebne.
#
# Do mierzenia czasu służy Measure-Command
#Measure-Command {Get-ChildItem -Path C:\Windows}
Wynik:
"
Days              : 0
Hours             : 0
Minutes           : 0
Seconds           : 0
Milliseconds      : 11
Ticks             : 115512
TotalDays         : 1,33694444444444E-07
TotalHours        : 3,20866666666667E-06
TotalMinutes      : 0,00019252
TotalSeconds      : 0,0115512
TotalMilliseconds : 11,5512
"
Polecenie pokazuje czas wylistowania katalogu windows
#
# I tu też widzisz jak się listuje zawartość katalogu. Ale jest to nie wygodne. Może jest na to alias?
#Get-Alias | ? {$_.Definition -like "Get-ChildItem"}
Wynik
"
CommandType     Name                                               Version    Source
-----------     ----                                               -------    ------
Alias           dir -> Get-ChildItem
Alias           gci -> Get-ChildItem
Alias           ls -> Get-ChildItem
"
#
# i co? Widać znajome skróty? Szczególnie w systemach *nix-owych ;-)
# No to wylistujmy sobie wszystkie pliki i katalogi z katalogu głównego ale z odstępem czasowym.
#ls C:\ | %{Sleep -Milliseconds 250; return $_} | Format-Table
wynik:
"
Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        07.05.2022     07:24                PerfLogs
d-r---        05.01.2024     22:07                Program Files
d-r---        10.01.2024     23:18                Program Files (x86)
d-----        22.10.2023     22:15                Riot Games
d-r---        11.10.2023     15:02                Users
d-----        30.01.2024     14:44                Windows
d-----        02.01.2024     16:48                XboxGames
-a----        12.05.2023     04:28         112080 appverifUI.dll
-a----        15.12.2023     08:03          12288 DumpStack.log
-a----        12.05.2023     04:29          66160 vfcompat.dll
"
Zostały wylistowane pliki katalogu C w odstępie 250 milisekund każdy
#
# Wyobraź sobie, że teraz ze skryptu PS uruchamiasz wyzwalacz na aparacie po określonym czasie, który
# z kolei jest dynamicznie wyliczany na postawie np. pobranej z internetu wartości naświetlenia
# z jakiegoś serwisu www. Odfiltrowana i używana jako wartość. Abstrakcja ale zapewne da się coś takiego zrobić
#
#
#
#
#
#
#
# No dobra. Ale PS to nie tylko język do pisania skryptów. To przede wszystkim konsola więc można z niej
# uruchamiać inne programy. Do tego służy operator wołania "call", który ma postać znaku "&"
#& C:\Windows\notepad.exe
Polecenie uruchomiło notatnik (jako osobną aplikację, a nie kartę w notatniku, mimo iż notatnik był cały czas otwarty)
#
#
#
#
#
#
#
#
#
#
#
# Ok. Było listowanie modułów i komend. A teraz wylistujmy zainstalowane aplikacje/programy.
# Można się do tego dobrać na 2 sposoby.
# 1. W rejestrze poszukać
# 2. Odpytać WMI (Windows Management Instrumentation)
#
# 1. Rejestr
# Informacje o zainstalowanych aplikacjach są przechowywane w:
# HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall
# PS potrafi "wejść" do rejestru jak na dysk.
# Ale skoro o tym mowa to sprawdźmy jakie "dyski" są dostępne w PowerShell-u.
#Get-PSDrive
"
Name           Used (GB)     Free (GB) Provider      Root                                                        CurrentLocation
----           ---------     --------- --------      ----                                                        ---------------
Alias                                  Alias
C                 219,82       1097,82 FileSystem    C:\                                                        Windows\system32
Cert                                   Certificate   \
D                 192,45        347,49 FileSystem    D:\
E                   0,15       1476,01 FileSystem    E:\
Env                                    Environment
Function                               Function
G                   0,10        390,52 FileSystem    G:\
H                                      FileSystem    H:\
HKCU                                   Registry      HKEY_CURRENT_USER
HKLM                                   Registry      HKEY_LOCAL_MACHINE
I                                      FileSystem    I:\
Variable                               Variable
WSMan                                  WSMan
"
Wylistowało listę dysków
#
# Widać, że jest ich trochę oraz kilka takich nietypowych. Dwa z nich są odpowiedzialne za rejestr.
# Resztę na razie pominiemy. Zatem by wejść do rejestru można zrobić tak:
#
#cd hklm:\
Znajduję się w HKLM
#
# i przeglądać sobie rejestr jak zwykły system plików
#
#cd .\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall
aktualna ściezka: "PS HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall>"
#
# Wylistować sobie jego zawartość przez ls
Wylistowało bardzo dużą ilość tekstu
#
# ale to spowoduje wyświetlenie sporej ilości tekstu w brzydkiej postaci. Można to trochę zmienić
#cd HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall
#ls | %{
#    Get-ItemProperty $_.pspath | Select-Object DisplayName, InstallDate, UninstallString
#} | Format-Table -AutoSize
Te polecenia wyświetliły dużą ilość zainstalowanych aplikacji
 
# Zamiast listować na ekran, można by odinstalować korzystając z operatora wołania "&" tak jak wyżej z notatnikiem
# tylko tutaj będzie to wyglądało tak:
#(nie uruchamiaj jeśli nie chcesz mieć odinstalowanych wszystkich aplikacji!
#cd HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall
#ls | %{
#    Get-ItemProperty $_.pspath | Select-Object DisplayName, InstallDate, UninstallString
#} | %{& $_.UninstallString}
Nie uruchamiam
#
#
#
#
#
#
#
# 2. WMI
# WMI służy do zarządzania systemem i można z niego wiele ciekawych rzeczy wyciągnąć.
#Get-WmiObject -Class Win32_Product | Format-Table -AutoSize
Ponownie została wyświetlona lista zainstalowanych aplikacji
# Te numery z przodu są brzydkie, bardzo podobne i zajmują dużo miejsca a nie wnoszą nic ciekawego teraz.
# Wyeliminujmy je:
#Get-WmiObject -Class Win32_Product | Select-Object Name, Vendor | Format-Table -AutoSize
Numery zostały usunięte
# a jakbyśmy chcieli znaleźć wszystkie pakiety od Microsoftu ?
#Get-WmiObject -Class Win32_Product | ?{$_.Vendor.toLower() -like "*microsoft*"} | Select-Object Name, Vendor | Format-Table -AutoSize
Zostały wyświetlone zainstalowane aplikacje Microsoft Corporation
# a teraz je odinstalować? (odinstalowywanie zostało osobno dodatkowo zakomentowane)
#
### Początek bloku do odkomentowania
#Get-WmiObject -Class Win32_Product | ?{$_.Vendor.toLower() -like "*microsoft*"} | %{
#	$wmiProduct = $_
#    $answer = Read-Host "Uninstall '$($wmiProduct.Name)' [y/n]"
#    $answer = $answer.ToLower()
#    switch($answer) {
#        "y" {
#            Write-Host -NoNewline -ForegroundColor Red "Removing: "
#            Write-Host -ForegroundColor White "$($wmiProduct.Name)"
#            # odkomentowanie poniższej lini spowoduje błąd braku uprawnień dla Twojego konta
#            #$wmiProduct.Uninstall() # ta linia uruchamia deinstalację. Odkomentuj jeśli chcesz odinstalować wszystkie pakiety od Microsoftu. (nie polecam)
#        }
#        "n" {Write-Host "Ok. Skipping."}
#        default {Write-Host -ForegroundColor Red "Unexpected value. Skipping uninstalling it."}
#    }
#}
### Koniec bloku do odkomentowania
Nie odinstalowywuję aplikacji Microsoftu
#
#
#
#
#
#
#
# Dyski w PS
# Wspomniałem, że PowerShell ma wiele dysków. Możemy je sobie wylistować poniższą komendą:
#Get-PSDrive
"
Name           Used (GB)     Free (GB) Provider      Root                                                        CurrentLocation
----           ---------     --------- --------      ----                                                        ---------------
Alias                                  Alias
C                 219,82       1097,81 FileSystem    C:\                                                        Windows\system32
Cert                                   Certificate   \
D                 192,45        347,49 FileSystem    D:\
E                   0,15       1476,01 FileSystem    E:\
Env                                    Environment
Function                               Function
G                   0,10        390,52 FileSystem    G:\
H                                      FileSystem    H:\
HKCU                                   Registry      HKEY_CURRENT_USER
HKLM                                   Registry      HKEY_LOCAL_MACHINE                  ...oft\Windows\CurrentVersion\Uninstall
I                                      FileSystem    I:\
Variable                               Variable
WSMan                                  WSMan
"
Ponownie zostały wylistowane dyski
# Mamy tu dyski z pojedynczymi literkami. To normalne dyski w windowsie.
# Dyski HKML i HKCU to dyski dające dostęp do rejestru.
# Poza tym są jeszcze:
# - Alias - lista wszystkich zdefiniowanych aliasów w bierzącej sesji. Tam są m.in. ls, dir, ?, %
# - Cert - magazyn certyfikatów TLS/SSL stosowanych do szyfrowania danych. Głównie połączeń sieciowych ale też i emaili czy podpisywania danych by można było sprawdzić czy treść np. dokumentu nie została zmodyfikowana. Swoją drogą skrypty PowerShell-owe też można podpisać cyfrowo
# - Env - zmienne środowiskowe w bierzącej sesji.
# - Function - tu są wszystkie zdefiniowane w bierzącej sesji funkcje, które można uruchomić. Podziałamy na funkcjach za chwilkę.
# - Variable - zmienne utworzone i dostępne w bierzącej sesji. NIE SĄ to zmienne środowiskowe tylko takie zmienne lokalne.
# - WSMan - dostęp do całego systemu WMI. Czyli to co powyżej było robione poprzez Get-WmiObject można by było spróbować pobrać z tego dysku
#
# Poza tymi dyskami są jeszcze inne, które można sobie dodać/dograć np:
# - GH - GitHub - tak, można po githubie "chodzić" w PowerShell-u
# - AD - ActiveDirectory - dodaje dysk dający dostęp do ActiveDirectory
		Dla tych co wiedzą co to jest to otwiera nowe możliwości.
		Dla tych co nie wiedzą jest kolejnym dyskiem.
# Takie dyski dodaje się przez załadowanie specjalnych modułów, które takie dyski udostępniają.
#
#
#
#
#
#
#
#
#
#
# A teraz notyfikacje :-D
# Część przykładu pobrałem z tej strony:
# http://www.powertheshell.com/balloontip/
#
# Trzeba załadować odpowiednią bibliotekę żeby można było skorzystać z tego cuda
### Początek bloku do odkomentowania
#[void] [System.Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms")
#
#$icoPath = Get-Process -id $pid | Select-Object -ExpandProperty Path
#
#$myNotification = New-Object System.Windows.Forms.NotifyIcon
#$myNotification.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon($icoPath)
#$myNotification.BalloonTipIcon = 'Error'
#$myNotification.BalloonTipText = "Your cat has meowed!" 
#$myNotification.BalloonTipTitle = "Cat Error"
#$myNotification.Visible = $True 
#$myNotification.ShowBalloonTip(10000)
### Koniec bloku do odkomentowania
#
#
#
# Ponieważ powyższe wydaje się być trochę mozolne by za każdym razem podawać te same wartości itd...
# To można zrobić sobie własną funkcję. Uruchomienie jej znajduje się poniżej więc nie trzeba jej komentować
# bo jak się jej nie wywoła to nic nie zrobi
#
function GiveMePopup {
    param(
        [Parameter(Mandatory=$true)]
        $Text,
   
        [Parameter(Mandatory=$true)]
        $Title,
   
        [ValidateSet('None', 'Info', 'Warning', 'Error')]
        $Icon = 'Info',

        $Timeout = 10000
    )
    [void] [System.Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms")
    $icoPath = Get-Process -id $pid | Select-Object -ExpandProperty Path
    $myNotification = New-Object System.Windows.Forms.NotifyIcon
    $myNotification.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon($icoPath)
    $myNotification.BalloonTipIcon = $Icon
    $myNotification.BalloonTipText = $Text 
    $myNotification.BalloonTipTitle = $Title
    $myNotification.Visible = $True 
    $myNotification.ShowBalloonTip(1000)
}
#
# I teraz można to łatwo wywołać w ten sposób
#
#GiveMePopup -Text "Your cat has meowed!" -Title "Cat Error" -Icon Error
Pojawiło się powiadomienie w rogu ekranu o miauczeniu kota :
# Albo wielokrotnie:
For($i = 1; $i -le 10; $i++) {
    GiveMePopup -Text "WTF-second passed!" -Title "WTF Notification" -Icon Info
}
Pojawiają się powiadomienia w rogu ekranu co chwilę
#
# Można też wiele wierszy pokazać ale max 4
#GiveMePopup -Text "Pierwszy wiersz`nDrugi wiersz`nTrzeci wiersz`nCzwarty wiersz" -Title "Długa informacja" -Icon Info
Pojawiło się powiadomienie z paroma wierszami
#
#
#
#
#
#
#
#
#
#
# I co? Fajne co nie? :-D